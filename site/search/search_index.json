{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LASER documentation","text":"<p>LASER (Light Agent Spatial modeling for ERadication) is a high-performance, agent-based simulation framework for modeling the spread of infectious diseases. It supports spatial structure, age demographics, and modular disease logic using Python-based components.</p> <p>The LASER framework is designed to be flexible. The basis of the framework, <code>laser-core</code>, is comprised of modular components which can be used to create custom epidemiological models. For those who wish to explore disease dynamics without the need to code from scratch, the development team is creating pre-built models, which will include a generic epidemiological model and disease-specific models. These pre-built models range from simple compartmental models to more complex agent-based models with spatial dynamics. And finally, for those who wish to contribute to code, the framework is open source and contributions are welcome!</p>"},{"location":"development/","title":"Development and Contributing to Code","text":"<p>Here's where all the relevant info for submitting tickets for bugs or feature requests, how to contribute to code, etc should go. No need to include persona information, users will navigate the docs based on what tasks they want to do. [If needed, this topic can be broken up with subtopic pages]</p>"},{"location":"development/#bugs-and-improvements","title":"Bugs and improvements","text":"<p>all info for filing tickets, requesting doc improvements, or new features can go here (it should all basically be \"how to file a ticket with us on GH\")</p>"},{"location":"development/#contributing-to-code","title":"Contributing to code","text":"<p>Introduction to the topic: will include the basic how-tos of working with the IDM team as well as how to actually work on LASER code</p>"},{"location":"development/#github-best-practices","title":"GitHub best practices","text":"<p>how to engage with IDM on GH, what's required for PRs etc (not bug tickets but how to fork &amp; submit PRs)</p>"},{"location":"development/#development-best-practices","title":"Development best practices","text":"<p>other help that's not related to unit tests or code optimization, relevant info from the \"iterative development cycle\" can go here (only if it's actual workflow steps; don't include if that's just a generalized workflow)</p>"},{"location":"development/#running-testsunit-tests","title":"Running tests/unit tests","text":"<p>all relevant sections on unit tests and code testing</p>"},{"location":"development/#optimizing-code","title":"Optimizing code","text":"<p>I'd include the help with Numba, Numpy here, and the info on C and OpenMP.</p>"},{"location":"glossary/","title":"Glossary","text":"<p>lower priority, but a glossary of terms (would definitely include all laser-specific terms, eg \"component\" so that users have an additional reference manual for help)</p>"},{"location":"installation/","title":"Installation and software requirements","text":"<p>LASER was developed to fulfill a variety of modeling needs. <code>Laser-core</code> can be installed standalone with:</p> <pre><code>pip install laser-core\n</code></pre> <p>Install <code>laser-core</code> if you are interested in using the components to develop your own, customized model. More information on modeling with <code>laser-core</code> can be found in Creating Custom Models.</p>"},{"location":"installation/#laser-disease-models","title":"LASER disease models","text":"<p>If you are interested in exploring model dynamics with <code>laser-generic</code> or other disease-specific models, you can find installation and user instructions in Laser Disease Models.</p>"},{"location":"installation/#laser-development","title":"LASER development","text":"<p>If you are interested in contributing to code, instructions on how to install for development can be found in Development.</p>"},{"location":"installation/#setting-up-an-ai-interface","title":"Setting up an AI interface","text":"<p>Info on Jenner, or other AI set-up instructions</p>"},{"location":"parameters/","title":"Parameter Reference","text":"<p>API docs!! All the relevant info needs to be here (placeholder for API docs; may need to create a folder and landing page for TOC structure)</p>"},{"location":"whatsnew/","title":"Changelog","text":""},{"location":"whatsnew/#001-2023-11-18","title":"0.0.1 (2023-11-18)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"get-started/","title":"Get Started Modeling","text":"<p>This is the basis for USING laser. Any type of \"quickstart\" info, all the how-to, what to do, etc goes in this section. This landing page should provide a layout of the relevant topics, and let users know that there are prebuilt disease models (including generic) as well as bespoke modeling options using core.</p>"},{"location":"get-started/#pre-built-laser-disease-models","title":"Pre-built LASER disease models","text":"<p>Link away to docsets for Generic, Measles, Cholera? (others as they're built)</p> <p>Will want the disease-specific docsets to contain:</p> <ul> <li>installation/setup/requirements</li> <li>new features/modules (eg what's added from core)</li> <li>creating sims</li> <li>running sims</li> <li>calibration</li> <li>tutorials &amp; examples</li> <li>parameters &amp; api docs</li> </ul>"},{"location":"get-started/#creating-custom-models-with-laser-core","title":"Creating custom models with LASER-Core","text":""},{"location":"get-started/calibration/","title":"Calibrating Custom Models","text":"<p>LASER can be calibrated using Optuna. Calibration is a process of tuning model parameters to fit real-world data, to ensure that model output provides accurate insights. Calibration can also be used as a method to help debug your model, as an inability to recreate known phenomena can help pinpoint issues in model code. For more information on calibration, check out IDM's ModelingHub.</p>"},{"location":"get-started/calibration/#simple-local-calibration","title":"Simple local calibration","text":""},{"location":"get-started/calibration/#local-dockerized-calibration","title":"Local Dockerized calibration","text":""},{"location":"get-started/calibration/#cloud-calibration","title":"Cloud calibration","text":""},{"location":"get-started/complexity/","title":"Adding Model Complexity","text":"<p>This will include how-to's for setting up the cool bits</p>"},{"location":"get-started/complexity/#vital-dynamics","title":"Vital dynamics","text":""},{"location":"get-started/complexity/#adding-spatial-features","title":"Adding spatial features","text":""},{"location":"get-started/complexity/#adding-migration","title":"Adding migration","text":""},{"location":"get-started/custom/","title":"Creating Custom Models","text":"<p>How to model using LASER-core components</p> <p>Installation should be already done, those instructions were on the installation page (link to it)</p> <p>Potential list of topics (edit based on how you actually do this! This may end up being a landing page, and each topic has its own page)</p>"},{"location":"get-started/custom/#assembling-componentsbuilding-a-model","title":"Assembling components/building a model","text":"<p>make sure to include the base requirements: what components are needed to run a model? How do you create the base model? (define parameters, add components, run sim, visualize output?)</p>"},{"location":"get-started/custom/#manually","title":"Manually","text":""},{"location":"get-started/custom/#setting-up-jenner-or-your-own-ai-interface","title":"Setting up Jenner (or your own AI interface)","text":"<p>how to use an AI interface, suggested prompts, etc</p>"},{"location":"get-started/custom/#running-simulations","title":"Running simulations","text":""},{"location":"get-started/custom/#visualize-output","title":"Visualize output","text":"<p>Note: pulled out the sections loading data, initializing populations, squashing/saving/loading, and put them on a separate topic page. BUT if they should all be done prior to running sims, then should integrate them into this page, with \"running simulations\" as the last step. (I don't fully understand how to actually build a model yet, so this section of the TOC is still squishy).</p> <p>This page should focus on the basics of what to do, all of the \"additional\" tasks are subpages.</p> <p>Make sure to capture all relevant steps that are currently in tutorials. Users should be able to look here for basic instructions.</p>"},{"location":"get-started/initialization/","title":"Loading Data and Initializing Populations","text":"<p>On the fence about making this a separate page, or including in the main page with the \"building\" sections; mostly, if these are somewhat optional but will make the model better, should have a separate topic page. If they're necessary, put back on the landing page (prior to \"running simulations\")</p>"},{"location":"get-started/initialization/#loading-data","title":"Loading data...","text":""},{"location":"get-started/initialization/#initializing-populations","title":"Initializing populations","text":""},{"location":"get-started/initialization/#squashing-saving-loading","title":"Squashing, saving, loading ..?","text":"<p>Note that the code example fr</p>"},{"location":"get-started/initialization/#other-pre-run-tasks-","title":"Other pre-run tasks :-)","text":""},{"location":"get-started/optimization/","title":"Optimizing Custom Models","text":"<p>As an agent-based model, research using LASER will require thousands of simulation replicates. While the model is designed to perform well with populations of thousands of agents, there is still a need to utilize high compute power and to optimize model performance.</p> <p>When creating custom models, knowing how to identify and fix performance bottlenecks can save compute time and speed results.</p>"},{"location":"get-started/optimization/#identifying-bottlenecks","title":"Identifying bottlenecks","text":""},{"location":"get-started/optimization/#leveraging-ai","title":"Leveraging AI","text":""},{"location":"get-started/optimization/#implementing-unit-tests","title":"Implementing unit tests","text":""},{"location":"get-started/optimization/#optimizing-with-numpy-and-numba","title":"Optimizing with NumPy and Numba","text":""},{"location":"get-started/optimization/#c-and-openmp","title":"C and OpenMP","text":""},{"location":"software-overview/","title":"Software Overview","text":"<p>LASER is a modeling framework that includes a variety of ways for users to implement the code to model infectious diseases. At the root of the framework is LASER-core, a suite of components that can be assembled or customized to fit specific modeling needs. The LASER development team is also in the process of producing pre-built disease models crafted from LASER-core components, which are tailored to address specific public health modeling questions. You can learn more about creating custom models using LASER-core or running models using pre-built disease models in the Get Started Modeling section.</p>"},{"location":"software-overview/#design-principles","title":"Design principles","text":"<p>The philosophy driving the development of LASER was to create a framework that was flexible, powerful, and fast, able to tackle a variety of complex modeling scenarios without sacrificing performance. But complexity often slows performance, and not every modeling question requires a full suite of model features. To solve this problem, LASER was designed as a set of core components, each with fundamental features that could be added--or not--to build working models. Users can optimize performance by creating models tailored to their research needs, only using components necessary for their modeling question. This building-block framework enables parsimony in model design, but also facilitates the building of powerful models with bespoke, complex dynamics.</p>"},{"location":"software-overview/#software-architecture","title":"Software architecture","text":"<p>Framework of how laser works:</p>"},{"location":"software-overview/#input-and-output-files","title":"Input and output files","text":"<p>All info on the input files and output files. If there are built-in reports, include those. Any type of data requirements should also be included here.</p> <p>Even if there are no \"required\" files, there still needs to be guidelines on formats, basic information needs, example files, etc. Better to provide some guidelines and let users know they're flexible than to say \"anything goes\" with out any starting point</p>"},{"location":"software-overview/modules/","title":"Modules (or Models? Classes?)","text":"<p>Looks like there are \"model classes\" that manage components?? (Looking at the Vital Dynamics Model page)</p> <p>Rename \"Classes\" depending on what the architecture actually is.</p> <p>May need a drop-down section like components if we have multiple types; right now it looks like Vital Dynamics would go here</p> <p>If the vital dynamics model is a combination of demographics components (eg not a stand alone, usable feature of the model), it can be included under the \"adding complexity\" section of the get started modeling section.</p>"},{"location":"software-overview/components/","title":"Software Components","text":"<p>Components are modular units of functionality within the simulation, responsible for performing specific updates or computations on the agent population or node-level data. Each component is implemented as a class with an initialization function to set up any required state and a step function to execute the component\u2019s logic during each timestep.</p> <p>[Deep dive into components and how they work, how they comprise laser functionality. Each \"type\" of component will have a topic section as needed]</p> <p>Make it clear that this is not a comprehensive list, but a call-out for the various functions the user can play with (link to API docs for full listing of laser functions)</p> <p>Need to make sure we explain all of the relevant/important parts! Eg, the classes used in the SIR tutorial should be all explained.</p>"},{"location":"software-overview/components/database/","title":"Simulation Data and Properties","text":"<p>I think it's worth calling out LaserFrame and PropertySet as features, since this is where the nuts and bolts seem to happen (page could use a better title)</p> <p>LaserFrame: basically a database that manages the dynamically allocated data for agents and nodes</p> <p>PropertySet: stores the agent properties in a dictionary-like object (such as infection status, region, exposure timers, etc)</p>"},{"location":"software-overview/components/demographics/","title":"Demographics","text":"<p>Need to an an intro, explaining generalizations about demographics for LASER.</p> <p>ALL topics about demographics will go here:</p> <ul> <li>Age structure</li> <li>Births</li> <li>Deaths</li> <li>All the vital dynamics sections??</li> <li>population pyramids</li> <li>kapalan-meier estimator</li> <li>etc</li> </ul> <p>Just pasted in content from the various topics; this will need an intro and text explaining how to configure these, how they fit together (eg, when to use age pyrmaids, when to use kaplan-meier); also code blocks, etc need to be formatted</p> <p>SO: Vital dynamics model: that section probably needs its own topic page, since it's long. Still kind of confused about what a \"model\" is in terms of laser components--is this a stand-alone model? Or the 'piece' that implements vital dynamics within an actual model? The answer to that will determine where we put the VDM topic page in the TOC.</p> <p>Also, make sure to link to appropriate topics! (esp parameters)</p>"},{"location":"software-overview/components/demographics/#age-structure","title":"Age structure","text":"<p>If you want to work with age structure for a short simulation which doesn\u2019t need births you can just give everyone an age (based on distribution) and increment it each timestep. The laser_core.demographics.pyramid module is provided to support the initialization of agents with plausible initial ages.</p>"},{"location":"software-overview/components/demographics/#births","title":"Births","text":""},{"location":"software-overview/components/demographics/#preborn-management-in-laser","title":"Preborn management in LASER","text":"<p>LASER\u2019s design philosophy emphasizes contiguous and fixed-size arrays, meaning all agents\u2014both currently active and preborn\u2014are created at the start of the simulation. Preborns are \u201cactivated\u201d as they are born, rather than being dynamically added. Several approaches to handling preborns while adhering to these principles are outlined below:</p> <p>Negative and Positive Birthdays: - Assign date_of_birth values in the past (negative) for active agents. - Assign date_of_birth values in the future (positive) for preborns.</p> <p>Unified Preborn Marker: - Set all preborns\u2019 date_of_birth to a placeholder value (e.g., -1). - Update the date_of_birth to the current timestep when a preborn is born.</p> <p>Active Flag Only (if not modeling age structure): - If the model doesn\u2019t require age structure, you can skip date_of_birth entirely. Instead, use an active flag. Preborns start with active = False and are switched to active = True during the fertility step. This simplifies implementation while remaining consistent with LASER principles.</p>"},{"location":"software-overview/components/demographics/#calculating-age-from-birthday","title":"Calculating age from birthday","text":"<p>If calculating age isn\u2019t frequent or essential, you can avoid explicitly tracking an age property. Instead, compute age dynamically as the difference between the current timestep (now) and date_of_birth. For models that depend on age-specific dynamics (e.g., fertility rates by age group), consider adding a dedicated age property that updates at each timestep.</p>"},{"location":"software-overview/components/demographics/#deaths","title":"Deaths","text":"<p>The recommended way of doing mortality in LASER is by precalculating a lifespan for each agent, rather than probabilistically killing agents as the simulation runs. This can take different forms: If you prefer to track agent age, you can also have an agent lifespan. Alternatively, if you are just using date_of_birth you can have a date_of_death, where theses \u2018dates\u2019 are really simulation times (\u2018sim day of birth\u2019 and \u2018sim day of death\u2019). Also, in LASER, as mentioned in the \u2018Principles\u2019 section, we strive to leave the contiguous arrays of agent data in place, without adding or deleting elements (allocating or freeing). This means that to model mortality, we prefer to \u2018kill\u2019 agents by doing either 1) check that their age is greater than their lifespan (or that the current timestep is greater than their \u2018sim day of death\u2019) in each component that cares, or 2) Set an active flag to false or a dead flag to true. The second approach is simpler, and avoids doing millions of comparison operations, at the cost of an additional property. Note that many component operations (step functions) can be done without checking whether the agent is alive, because, for example, as long as transmission never infects a dead person, decrementing all non-zero infection timers will only operate on live agents. Finally, while you can set lifespans using any algorith you want, laser_core.demographics.kmestimator is provided to support these calculations.</p>"},{"location":"software-overview/components/demographics/#population-pyramids","title":"Population pyramids","text":"<p>The AliasedDistribution class provides a way to sample from a set of options with unequal probabilities, e.g., a population pyramid.</p> <p>The input to the AliasedDistribution constructor is an array of counts by bin as we would naturally get from a population pyramid (# of people in each age bin).</p> <p>AliasedDistribution.sample() returns bin indices so it is up to the user to convert the values returned from sample() to actual ages.</p> <p>Expected format of the population pyramid CSV file for load_pyramid_csv(): [insert examples]</p>"},{"location":"software-overview/components/demographics/#kaplan-meier-estimators","title":"Kaplan-Meier estimators","text":"<p>The KaplanMeierEstimator is used to predict age or year of death. It takes an array of cumulative deaths and returns an object that will sample from the Kaplan-Meier distribution.</p> <p>A sample input array of cumulative deaths might look like this:</p> <pre><code>cd[0] = 687 # 687 deaths in the first year (age 0)\ncd[1] = 733 # +46 deaths in the second year (age 1)\ncd[2] = 767 # +34 deaths in the third year (age 2)\n...\ncd[100] = 100_000  # 100,000 deaths by end of year\n</code></pre> <p><code>predict_year_of_death()</code> takes an array of current ages (in years) and returns an array of predicted years of death based on the cumulative deaths input array.</p> <p>Note</p> <p><code>predict_year_of_death()</code> can use non-constant width age bins and will return predictions by age bin. In this case, it is up to the user to convert the returned bin indices to actual years.</p> <p>A sample non-constant width age bin input array might look like this:</p> <pre><code>cd[0] = 340 # 1/2 of first year deaths in the first 3 months\ncd[1] = 510 # another 1/4 (+170) of first year deaths in the next 3 months\ncd[2] = 687 # another 1/4 (+177) of first year deaths in the last 6 months\ncd[3] = 733 # 46 deaths in the second year (age 1)\ncd[4] = 767 # 34 deaths in the third year (age 2)\n...\ncd[103] = 100_000  # 100,000 deaths by end of year 100\n</code></pre> <p>In this example, values returned from predict_year_of_death() would need to be mapped as follows:</p> <pre><code>0 -&gt; (0, 3] months\n1 -&gt; (3, 6] months\n2 -&gt; (6, 12] months\n3 -&gt; 1 year\n4 -&gt; 2 years\n...\n102 -&gt; 100 years\n</code></pre> <p><code>predict_age_at_death()</code> takes an array of current ages (in days) and returns an array of predicted ages (in days) at death. The implementation assumes that the cumulative deaths input array to the estimator represents one year age bins. If you are using non-constant width age bins, you should manually convert bin indices returned from <code>predict_year_of_death()</code> to ages.</p>"},{"location":"software-overview/components/demographics/#spatial-distributions-of-populations","title":"Spatial distributions of populations","text":"<p>[Added here since it's part of the demographics subpackage, but it might make more sense with the migration information]</p>"},{"location":"software-overview/components/migration/","title":"Migration","text":"<p>ADD INTRO. Explain how LASER has the variout types of migration models, that the user can select how to implement migration using the following types.</p>"},{"location":"software-overview/components/migration/#gravity-model","title":"Gravity model","text":"<p>The gravity model [link to a good source on GM] can be used to compute the migration of people between nodes located at specific distances.</p> <p>The following example demonstrates implementing the gravity model to calculate the number of migrants moving between nodes. Agents are randomly assigned to different migration paths.</p> <pre><code>import numpy as np\nfrom laser_core.migration import gravity\n\n# Define populations and distances\npopulations = np.array([5000, 10000, 15000, 20000, 25000])  # Unequal populations\ndistances = np.array([\n    [0.0, 10.0, 15.0, 20.0, 25.0],\n    [10.0, 0.0, 10.0, 15.0, 20.0],\n    [15.0, 10.0, 0.0, 10.0, 15.0],\n    [20.0, 15.0, 10.0, 0.0, 10.0],\n    [25.0, 20.0, 15.0, 10.0, 0.0]\n])\n\n# Gravity model parameters\nk = 0.1    # Scaling constant\na = 0.5    # Exponent for the population of the origin\nb = 1.0    # Exponent for the population of the destination\nc = 2.0    # Exponent for the distance\n\n# Compute the gravity model network\nmigration_network = gravity(populations, distances, k=k, a=a, b=b, c=c)\n\n# Normalize to ensure total migrations represent 1% of the population\ntotal_population = np.sum(populations)\nmigration_fraction = 0.01  # 1% of the population migrates\nscaling_factor = (total_population * migration_fraction) / np.sum(migration_network)\nmigration_network *= scaling_factor\n\n# Generate a node ID array for agents\nnode_ids = np.concatenate([np.full(count, i) for i, count in enumerate(populations)])\n\n# Initialize a 2D array for migration counts\nmigration_matrix = np.zeros_like(distances, dtype=int)\n\n# Select migrants based on the gravity model\nfor origin in range(len(populations)):\n    for destination in range(len(populations)):\n        if origin != destination:\n            # Number of migrants to move from origin to destination\n            num_migrants = int(migration_network[origin, destination])\n            # Select migrants randomly\n            origin_ids = np.where(node_ids == origin)[0]\n            selected_migrants = np.random.choice(origin_ids, size=num_migrants, replace=False)\n            # Update the migration matrix\n            migration_matrix[origin, destination] = num_migrants\n</code></pre>"},{"location":"software-overview/components/migration/#sequential-migration-matrix","title":"Sequential migration matrix","text":"<p>Saw a reference to this in the \"simple spatial SIR model with synthetic data\" section, so need info on it.</p>"},{"location":"software-overview/components/migration/#the-competing-destinations-model","title":"The competing destinations model","text":""},{"location":"software-overview/components/migration/#stouffers-rank-model","title":"Stouffer's rank model","text":""},{"location":"software-overview/components/migration/#radiation-model","title":"Radiation model","text":""},{"location":"tutorials/","title":"Tutorials and Examples","text":"<p>This will definitely need some secondary structure, so that the tutorials make sense and are findable. They will likely include tutorials for a variety of tasks, so organization is key. Also note that code blocks that are examples of specific instructions/topics should go on the topic page; this section is where users will run models and do more end-to-end workflow type examples. Can also link to notebooks here (but make sure notebooks have good introductions and explanations</p> <p>[include internal TOC for list of examples with little intros about them]</p> <p>Note: had this under the \"getting started\" section, but thinking it is better served as a L1 topic.</p> <p>Add the notebooks for KM estimator, age pyramid (?)</p>"},{"location":"tutorials/age_pyramid/","title":"Age Pyramid Examples","text":"In\u00a0[84]: Copied! <pre>from pathlib import Path\n\nimport numpy as np\n\nfrom laser_core.demographics import AliasedDistribution\nfrom laser_core.demographics import load_pyramid_csv\n</pre> from pathlib import Path  import numpy as np  from laser_core.demographics import AliasedDistribution from laser_core.demographics import load_pyramid_csv  In\u00a0[85]: Copied! <pre>MCOL = 2\nFCOL = 3\n\nMINCOL = 0\nMAXCOL = 1\n\nnigeria = load_pyramid_csv(Path.cwd() / \"Nigeria-2024.csv\")\nsampler = AliasedDistribution(nigeria[:, MCOL])    # We'll use the male population in this example.\nn_agents = 100_000\nsamples = sampler.sample(n_agents)              # Sample 100,000 people from the distribution.\n# samples will be bin indices, so we need to convert them to ages.\nbin_min_age_days = nigeria[:, MINCOL] * 365          # minimum age for bin, in days (include this value)\nbin_max_age_days = (nigeria[:, MAXCOL] + 1) * 365    # maximum age for bin, in days (exclude this value)\nmask = np.zeros(n_agents, dtype=bool)\nages = np.zeros(n_agents, dtype=np.int32)\nfor i in range(len(nigeria)):   # for each possible bin value...\n    mask[:] = samples == i      # ...find the agents that belong to this bin\n    # ...and assign a random age, in days, within the bin\n    ages[mask] = np.random.randint(bin_min_age_days[i], bin_max_age_days[i], mask.sum())\n</pre> MCOL = 2 FCOL = 3  MINCOL = 0 MAXCOL = 1  nigeria = load_pyramid_csv(Path.cwd() / \"Nigeria-2024.csv\") sampler = AliasedDistribution(nigeria[:, MCOL])    # We'll use the male population in this example. n_agents = 100_000 samples = sampler.sample(n_agents)              # Sample 100,000 people from the distribution. # samples will be bin indices, so we need to convert them to ages. bin_min_age_days = nigeria[:, MINCOL] * 365          # minimum age for bin, in days (include this value) bin_max_age_days = (nigeria[:, MAXCOL] + 1) * 365    # maximum age for bin, in days (exclude this value) mask = np.zeros(n_agents, dtype=bool) ages = np.zeros(n_agents, dtype=np.int32) for i in range(len(nigeria)):   # for each possible bin value...     mask[:] = samples == i      # ...find the agents that belong to this bin     # ...and assign a random age, in days, within the bin     ages[mask] = np.random.randint(bin_min_age_days[i], bin_max_age_days[i], mask.sum())  In\u00a0[86]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig, ax1 = plt.subplots()\n\n# Plot histogram of samples on primary y-axis\n\nfraction = nigeria[:, MCOL]/nigeria[:, MCOL:FCOL+1].sum()\nax1.plot(fraction, color=\"green\")\nax1.set_xlabel(\"Age Bin\")\nbins = [f\"{i, j}\" for i, j in zip(nigeria[:, MINCOL], nigeria[:, MAXCOL])]\nplt.xticks(rotation=90)\nax1.set_xticks(ticks=range(len(bins)), labels=bins)\nax1.set_ylim(-0.01, 0.1)\nax1.set_ylabel(\"% Population (Input)\", color=\"green\")\n\n# Create secondary y-axis\nax2 = ax1.twinx()\n\n# We will calculate the histogram manually because the final bin isn't the same width as the others.\nhistogram = np.zeros(21, dtype=np.int32)\nfor i in range(histogram.shape[0]):\n    mask = (ages // 1825) == i  # Convert ages in days to 5-year bin indices\n    histogram[i] = mask.sum()\n\nscale = nigeria[:,MCOL].sum() / nigeria[:,MCOL:FCOL+1].sum()   # male / male+female\nfraction = (histogram*scale)/histogram.sum()\nax2.plot(range(histogram.shape[0]), fraction, color=\"orange\", marker=\"x\")\nax2.set_ylim(-0.01, 0.1)\nax2.set_ylabel(\"% Population (Sampled)\", color=\"orange\")\n\nplt.title(\"Age Distribution in Nigeria\")\nplt.show()\n</pre> import matplotlib.pyplot as plt  fig, ax1 = plt.subplots()  # Plot histogram of samples on primary y-axis  fraction = nigeria[:, MCOL]/nigeria[:, MCOL:FCOL+1].sum() ax1.plot(fraction, color=\"green\") ax1.set_xlabel(\"Age Bin\") bins = [f\"{i, j}\" for i, j in zip(nigeria[:, MINCOL], nigeria[:, MAXCOL])] plt.xticks(rotation=90) ax1.set_xticks(ticks=range(len(bins)), labels=bins) ax1.set_ylim(-0.01, 0.1) ax1.set_ylabel(\"% Population (Input)\", color=\"green\")  # Create secondary y-axis ax2 = ax1.twinx()  # We will calculate the histogram manually because the final bin isn't the same width as the others. histogram = np.zeros(21, dtype=np.int32) for i in range(histogram.shape[0]):     mask = (ages // 1825) == i  # Convert ages in days to 5-year bin indices     histogram[i] = mask.sum()  scale = nigeria[:,MCOL].sum() / nigeria[:,MCOL:FCOL+1].sum()   # male / male+female fraction = (histogram*scale)/histogram.sum() ax2.plot(range(histogram.shape[0]), fraction, color=\"orange\", marker=\"x\") ax2.set_ylim(-0.01, 0.1) ax2.set_ylabel(\"% Population (Sampled)\", color=\"orange\")  plt.title(\"Age Distribution in Nigeria\") plt.show() In\u00a0[87]: Copied! <pre>america = load_pyramid_csv(Path.cwd() / \"United States of America-2024.csv\")\nsampler = AliasedDistribution(america[:, FCOL])    # We'll use the female population in this example.\nn_agents = 100_000\nsamples = sampler.sample(n_agents)              # Sample 100,000 people from the distribution.\n# samples will be bin indices, so we need to convert them to ages.\nbin_min_age_days = america[:, MINCOL] * 365          # minimum age for bin, in days (include this value)\nbin_max_age_days = (america[:, MAXCOL] + 1) * 365    # maximum age for bin, in days (exclude this value)\nmask = np.zeros(n_agents, dtype=bool)\nages = np.zeros(n_agents, dtype=np.int32)\nfor i in range(len(america)):   # for each possible bin value...\n    mask[:] = samples == i      # ...find the agents that belong to this bin\n    # ...and assign a random age, in days, within the bin\n    ages[mask] = np.random.randint(bin_min_age_days[i], bin_max_age_days[i], mask.sum())\n</pre> america = load_pyramid_csv(Path.cwd() / \"United States of America-2024.csv\") sampler = AliasedDistribution(america[:, FCOL])    # We'll use the female population in this example. n_agents = 100_000 samples = sampler.sample(n_agents)              # Sample 100,000 people from the distribution. # samples will be bin indices, so we need to convert them to ages. bin_min_age_days = america[:, MINCOL] * 365          # minimum age for bin, in days (include this value) bin_max_age_days = (america[:, MAXCOL] + 1) * 365    # maximum age for bin, in days (exclude this value) mask = np.zeros(n_agents, dtype=bool) ages = np.zeros(n_agents, dtype=np.int32) for i in range(len(america)):   # for each possible bin value...     mask[:] = samples == i      # ...find the agents that belong to this bin     # ...and assign a random age, in days, within the bin     ages[mask] = np.random.randint(bin_min_age_days[i], bin_max_age_days[i], mask.sum())  In\u00a0[88]: Copied! <pre>fig, ax1 = plt.subplots()\n\n# Plot histogram of samples on primary y-axis\n\nfraction = america[:, FCOL]/america[:, MCOL:FCOL+1].sum()\nax1.plot(fraction, color=\"g\")\nax1.set_xlabel(\"Age Bin\")\nplt.xticks(rotation=90)\nbins = [f\"{i, j}\" for i, j in zip(america[:, MINCOL], america[:, MAXCOL])]\nax1.set_xticks(ticks=range(len(bins)), labels=bins)\nax1.set_ylim(-0.01, 0.05)\nax1.set_ylabel(\"% Population (Input)\", color=\"g\")\n\n# We will calculate the histogram manually because the final bin isn't the same width as the others.\nhistogram = np.zeros(21, dtype=np.int32)\nfor i in range(histogram.shape[0]):\n    mask = (ages // 1825) == i  # Convert ages in days to 5-year bin indices\n    histogram[i] = mask.sum()\n\n# Create secondary y-axis\nax2 = ax1.twinx()\nscale = america[:,FCOL].sum() / america[:,MCOL:FCOL+1].sum()   # female / male+female\nfraction = (histogram*scale)/histogram.sum()\nax2.plot(range(histogram.shape[0]), fraction, color=\"orange\", marker=\"x\")\nax2.set_ylabel(\"% Population (Sampled)\", color=\"orange\")\nax2.set_ylim(-0.01, 0.05)\n\n\nplt.title(\"Age Distribution in the United States\")\nplt.show()\n</pre> fig, ax1 = plt.subplots()  # Plot histogram of samples on primary y-axis  fraction = america[:, FCOL]/america[:, MCOL:FCOL+1].sum() ax1.plot(fraction, color=\"g\") ax1.set_xlabel(\"Age Bin\") plt.xticks(rotation=90) bins = [f\"{i, j}\" for i, j in zip(america[:, MINCOL], america[:, MAXCOL])] ax1.set_xticks(ticks=range(len(bins)), labels=bins) ax1.set_ylim(-0.01, 0.05) ax1.set_ylabel(\"% Population (Input)\", color=\"g\")  # We will calculate the histogram manually because the final bin isn't the same width as the others. histogram = np.zeros(21, dtype=np.int32) for i in range(histogram.shape[0]):     mask = (ages // 1825) == i  # Convert ages in days to 5-year bin indices     histogram[i] = mask.sum()  # Create secondary y-axis ax2 = ax1.twinx() scale = america[:,FCOL].sum() / america[:,MCOL:FCOL+1].sum()   # female / male+female fraction = (histogram*scale)/histogram.sum() ax2.plot(range(histogram.shape[0]), fraction, color=\"orange\", marker=\"x\") ax2.set_ylabel(\"% Population (Sampled)\", color=\"orange\") ax2.set_ylim(-0.01, 0.05)   plt.title(\"Age Distribution in the United States\") plt.show()"},{"location":"tutorials/age_pyramid/#age-pyramid-examples","title":"Age Pyramid Examples\u00b6","text":"<p>We will use a U.S. age pyramid and a Nigerian age pyramid for examples.</p>"},{"location":"tutorials/age_pyramid/#nigeria","title":"Nigeria\u00b6","text":"<p>Source: https://www.populationpyramid.net/nigeria/2024/</p> <p></p>"},{"location":"tutorials/age_pyramid/#united-states","title":"United States\u00b6","text":"<p>Source: https://www.populationpyramid.net/united-states-of-america/2024/</p> <p></p>"},{"location":"tutorials/kmestimator/","title":"Example Date of Non-disease Death Estimation with KaplanMeierEstimator","text":"In\u00a0[11]: Copied! <pre>import numpy as np\n\ncumulative = np.array([\n     8131,  9396, 10562, 11636, 12620, 13506, 14287, 14958, 15523, 15997,   # year  0.. 9\n    16400, 16756, 17083, 17401, 17725, 18067, 18437, 18837, 19268, 19726,   # year 10..19\n    20207, 20705, 21215, 21732, 22256, 22785, 23319, 23860, 24407, 24961,   # year 20..29\n    25522, 26091, 26668, 27252, 27845, 28446, 29059, 29684, 30324, 30979,   # year 30..39\n    31649, 32334, 33031, 33737, 34452, 35176, 35913, 36666, 37442, 38247,   # year 40..49\n    39085, 39959, 40869, 41815, 42795, 43811, 44866, 45966, 47118, 48330,   # year 50..59\n    49608, 50958, 52380, 53876, 55442, 57080, 58790, 60574, 62435, 64372,   # year 60..69\n    66380, 68451, 70569, 72719, 74880, 77039, 79179, 81288, 83353, 85355,   # year 70..79\n    87274, 89085, 90766, 92299, 93672, 94884, 95936, 96837, 97594, 98216,   # year 80..89\n    98713, 99097, 99383, 99590, 99735, 99833, 99897, 99939, 99965, 99980,   # year 90..99\n    100000, # year 100+\n], dtype=np.int32)\n</pre> import numpy as np  cumulative = np.array([      8131,  9396, 10562, 11636, 12620, 13506, 14287, 14958, 15523, 15997,   # year  0.. 9     16400, 16756, 17083, 17401, 17725, 18067, 18437, 18837, 19268, 19726,   # year 10..19     20207, 20705, 21215, 21732, 22256, 22785, 23319, 23860, 24407, 24961,   # year 20..29     25522, 26091, 26668, 27252, 27845, 28446, 29059, 29684, 30324, 30979,   # year 30..39     31649, 32334, 33031, 33737, 34452, 35176, 35913, 36666, 37442, 38247,   # year 40..49     39085, 39959, 40869, 41815, 42795, 43811, 44866, 45966, 47118, 48330,   # year 50..59     49608, 50958, 52380, 53876, 55442, 57080, 58790, 60574, 62435, 64372,   # year 60..69     66380, 68451, 70569, 72719, 74880, 77039, 79179, 81288, 83353, 85355,   # year 70..79     87274, 89085, 90766, 92299, 93672, 94884, 95936, 96837, 97594, 98216,   # year 80..89     98713, 99097, 99383, 99590, 99735, 99833, 99897, 99939, 99965, 99980,   # year 90..99     100000, # year 100+ ], dtype=np.int32) In\u00a0[12]: Copied! <pre>from laser_core.demographics import KaplanMeierEstimator\n\nestimator = KaplanMeierEstimator(cumulative)\nnagents = 100_000\ndobs = np.zeros(nagents)    # dates of birth, newborns = 0\ndods = estimator.predict_age_at_death(dobs, max_year=100)   # dates of death in days\n</pre> from laser_core.demographics import KaplanMeierEstimator  estimator = KaplanMeierEstimator(cumulative) nagents = 100_000 dobs = np.zeros(nagents)    # dates of birth, newborns = 0 dods = estimator.predict_age_at_death(dobs, max_year=100)   # dates of death in days In\u00a0[13]: Copied! <pre>import matplotlib.pyplot as plt\n\nhistogram = np.zeros(cumulative.shape[0]+1, np.int32)\nyods = dods // 365  # years of death\nfor i in range(cumulative.shape[0]+1):\n    histogram[i] = np.sum(yods == i)\n\nfig, ax1 = plt.subplots()\n\ncolor = \"tab:orange\"\nax1.set_xlabel(\"Age\")\nax1.set_ylabel(\"Cumulative Sampled Deaths\", color=color)\nax1.plot(np.cumsum(histogram), color=color, marker=\"x\")\nax1.tick_params(axis=\"y\", labelcolor=color)\n\nax2 = ax1.twinx()\ncolor = \"tab:green\"\nax2.set_ylabel(\"Input Cumulative Deaths\", color=color)\nax2.plot(cumulative, color=color)\nax2.tick_params(axis=\"y\", labelcolor=color)\n\nfig.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt  histogram = np.zeros(cumulative.shape[0]+1, np.int32) yods = dods // 365  # years of death for i in range(cumulative.shape[0]+1):     histogram[i] = np.sum(yods == i)  fig, ax1 = plt.subplots()  color = \"tab:orange\" ax1.set_xlabel(\"Age\") ax1.set_ylabel(\"Cumulative Sampled Deaths\", color=color) ax1.plot(np.cumsum(histogram), color=color, marker=\"x\") ax1.tick_params(axis=\"y\", labelcolor=color)  ax2 = ax1.twinx() color = \"tab:green\" ax2.set_ylabel(\"Input Cumulative Deaths\", color=color) ax2.plot(cumulative, color=color) ax2.tick_params(axis=\"y\", labelcolor=color)  fig.tight_layout() plt.show() In\u00a0[17]: Copied! <pre>nagents = 100_000 - cumulative[49]          # how many 50+ years old do we expect?\ndobs = np.full(nagents, 365*50)             # dates of birth, 50 years old\ndobs += np.random.randint(0, 365, nagents)  # add random days\ndods = estimator.predict_age_at_death(dobs, max_year=100)   # dates of death in days\n</pre> nagents = 100_000 - cumulative[49]          # how many 50+ years old do we expect? dobs = np.full(nagents, 365*50)             # dates of birth, 50 years old dobs += np.random.randint(0, 365, nagents)  # add random days dods = estimator.predict_age_at_death(dobs, max_year=100)   # dates of death in days In\u00a0[19]: Copied! <pre>histogram = np.zeros(cumulative.shape[0]+1, np.int32)\nyods = dods // 365  # years of death\nfor i in range(cumulative.shape[0]+1):\n    histogram[i] = np.sum(yods == i)\n\nfig, ax1 = plt.subplots()\n\ncolor = \"tab:orange\"\nax1.set_xlabel(\"Age\")\nax1.set_ylabel(\"Cumulative Sampled Deaths\", color=color)\nax1.plot(np.cumsum(histogram), color=color, marker=\"x\")\nax1.tick_params(axis=\"y\", labelcolor=color)\n\nax2 = ax1.twinx()\ncolor = \"tab:green\"\nax2.set_ylabel(\"Input Cumulative Deaths (50+)\", color=color)\nsubsequent = np.maximum(cumulative - cumulative[49], 0)\nax2.plot(subsequent, color=color)\nax2.tick_params(axis=\"y\", labelcolor=color)\n\nfig.tight_layout()\nplt.show()\n</pre> histogram = np.zeros(cumulative.shape[0]+1, np.int32) yods = dods // 365  # years of death for i in range(cumulative.shape[0]+1):     histogram[i] = np.sum(yods == i)  fig, ax1 = plt.subplots()  color = \"tab:orange\" ax1.set_xlabel(\"Age\") ax1.set_ylabel(\"Cumulative Sampled Deaths\", color=color) ax1.plot(np.cumsum(histogram), color=color, marker=\"x\") ax1.tick_params(axis=\"y\", labelcolor=color)  ax2 = ax1.twinx() color = \"tab:green\" ax2.set_ylabel(\"Input Cumulative Deaths (50+)\", color=color) subsequent = np.maximum(cumulative - cumulative[49], 0) ax2.plot(subsequent, color=color) ax2.tick_params(axis=\"y\", labelcolor=color)  fig.tight_layout() plt.show()"},{"location":"tutorials/kmestimator/#example-date-of-non-disease-death-estimation-with-kaplanmeierestimator","title":"Example Date of Non-disease Death Estimation with KaplanMeierEstimator\u00b6","text":"<p>The Kaplan-Meier estimator uses survival information to draw for a date of death based on current age.</p> <p>Current age may be non-zero for an initial population or zero for newborn agents.</p>"},{"location":"tutorials/kmestimator/#drawing-for-date-of-non-disease-death-for-newborn-agents","title":"Drawing for Date of Non-disease Death for Newborn Agents\u00b6","text":"<p>The input to the KaplanMeierEstimator is the cumulative number of deaths by bin/age.</p> <p>The following data from Nigeria follow a hypothetical 100_000 person population giving the cumulative number of deaths by each age.</p>"},{"location":"tutorials/kmestimator/#drawing-for-date-of-non-disease-death-for-newborn-agents","title":"Drawing for Date of Non-disease Death for Newborn Agents\u00b6","text":"<p>The input to the KaplanMeierEstimator is the cumulative number of deaths by bin/age.</p> <p>The following data from Nigeria follow a hypothetical 50_000 person population giving the cumulative number of deaths by each age.</p>"},{"location":"tutorials/sir/","title":"Building SIR Models","text":"<p>One of the simplest and most commonly used models to describe the progression of an outbreak or epidemic is the SIR (Susceptible - Infected - Recovered) model. We can use the SIR model to explore how to use the LASER framework, staring with a basic SIR model and adding complexity.</p> <p>This tutorial will:</p> <ul> <li>Demonstrate how the <code>LASERframe</code> and <code>PropertySet</code> libraries are used</li> <li>Structure a basic disease transmission framework</li> <li>Track and visualize results</li> </ul> <p>As you progress through the sections, you will learn how to add spatial dynamics and migration into the disease model, using both synthetic and real-world data.</p>"},{"location":"tutorials/sir/#simple-sir","title":"Simple SIR","text":"<p>The SIR model presented here simulates disease dynamics within a closed population in a single node using the <code>LASERFrame</code> framework. The population starts with a defined number of susceptible and infected individuals, progresses over time with recovery and transmission components, and tracks results for visualization. This example serves as a practical guide for modeling simple epidemic dynamics. This simple example does not include vital dynamics, age-structured populations, vaccination, or other complex interactions.</p>"},{"location":"tutorials/sir/#model-components","title":"Model components","text":"<p>The <code>SIRModel</code> class is the core of the implementation. It initializes a population using <code>LaserFrame</code>, sets up disease state and recovery timer properties, and tracks results across timesteps.</p> Code example: Implementing <code>SIRModel</code> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom laser_core import LaserFrame\nfrom laser_core import PropertySet\n\nclass SIRModel:\n    def __init__(self, params):\n        # Model Parameters\n        self.params = params\n\n        # Initialize the population LaserFrame\n        self.population = LaserFrame(capacity=params.population_size,initial_count=params.population_size)\n\n        # Add disease state property (0 = Susceptible, 1 = Infected, 2 = Recovered)\n        self.population.add_scalar_property(\"disease_state\", dtype=np.int32, default=0)\n\n        # Add a recovery timer property (for intrahost progression, optional for timing)\n        self.population.add_scalar_property(\"recovery_timer\", dtype=np.int32, default=0)\n\n        # Results tracking\n        self.results = LaserFrame( capacity = 1 ) # number of nodes\n        self.results.add_vector_property( \"S\", length=params[\"timesteps\"], dtype=np.float32 )\n        self.results.add_vector_property( \"I\", length=params[\"timesteps\"], dtype=np.float32 )\n        self.results.add_vector_property( \"R\", length=params[\"timesteps\"], dtype=np.float32 )\n\n        # Components\n        self.components = []\n\n    def add_component(self, component):\n        self.components.append(component)\n\n    def track_results(self, tick):\n        susceptible = (self.population.disease_state == 0).sum()\n        infected = (self.population.disease_state == 1).sum()\n        recovered = (self.population.disease_state == 2).sum()\n        total = self.population.count\n        self.results.S[tick] = susceptible / total\n        self.results.I[tick] = infected / total\n        self.results.R[tick] = recovered / total\n\n    def run(self):\n        for tick in range(self.params.timesteps):\n            for component in self.components:\n                component.step()\n            self.track_results(tick)\n\n    def plot_results(self):\n        plt.figure(figsize=(10, 6))\n        plt.plot(self.results.S, label=\"Susceptible (S)\", color=\"blue\")\n        plt.plot(self.results.I, label=\"Infected (I)\", color=\"red\")\n        plt.plot(self.results.R, label=\"Recovered (R)\", color=\"green\")\n        plt.title(\"SIR Model Dynamics with LASER Components\")\n        plt.xlabel(\"Time (Timesteps)\")\n        plt.ylabel(\"Fraction of Population\")\n        plt.legend()\n        plt.grid()\n        plt.show()\n        plt.savefig(\"gpt_sir.png\")\n</code></pre> <p>The <code>IntrahostProgression</code> class manages recovery dynamics by updating infected individuals based on a given recovery rate.</p> Code example: Implementing <code>IntrahostProgression</code> <pre><code>class IntrahostProgression:\n    def __init__(self, model):\n        self.population = model.population\n\n        # Seed the infection\n        num_initial_infected = int(0.01 * params.population_size)  # e.g., 1% initially infected\n        infected_indices = np.random.choice(params.population_size, size=num_initial_infected, replace=False)\n        self.population.disease_state[infected_indices] = 1\n\n        # Initialize recovery timer for initially infected individuals\n        initially_infected = self.population.disease_state == 1\n        self.population.recovery_timer[initially_infected] = np.random.randint(5, 15, size=initially_infected.sum())\n\n    def step(self):\n        infected = self.population.disease_state == 1\n\n        # Decrement recovery timer\n        self.population.recovery_timer[infected] -= 1\n\n        # Recover individuals whose recovery_timer has reached 0\n        recoveries = infected &amp; (self.population.recovery_timer &lt;= 0)\n        self.population.disease_state[recoveries] = 2\n</code></pre> <p>The <code>Transmission</code> class manages disease spread by modeling interactions between susceptible and infected individuals.</p> Code example: Implementing <code>Transmission</code> <pre><code>class Transmission:\n    def __init__(self, model):\n        self.population = model.population\n        self.infection_rate = model.params.infection_rate\n\n    def step(self):\n        susceptible = self.population.disease_state == 0\n        infected = self.population.disease_state == 1\n\n        num_susceptible = susceptible.sum()\n        num_infected = infected.sum()\n        population_size = len(self.population)\n\n        # Fraction of infected and susceptible individuals\n        fraction_infected = num_infected / population_size\n\n        # Transmission logic: Probability of infection per susceptible individual\n        infection_probability = self.infection_rate * fraction_infected\n\n        # Apply infection probability to all susceptible individuals\n        new_infections = np.random.rand(num_susceptible) &lt; infection_probability\n\n        # Set new infections and initialize their recovery_timer\n        susceptible_indices = np.where(susceptible)[0]\n        newly_infected_indices = susceptible_indices[new_infections]\n        self.population.disease_state[newly_infected_indices] = 1\n        self.population.recovery_timer[newly_infected_indices] = np.random.randint(5, 15, size=newly_infected_indices.size)  # Random recovery time\n</code></pre> <p>The simulation parameters are defined using the <code>PropertySet</code> class.</p> Code example: Defining simulation parameters using <code>PropertySet</code> <pre><code>params = PropertySet({\n    \"population_size\": 100_000,\n    \"infection_rate\": 0.3,\n    \"timesteps\": 160\n})\n</code></pre> <p>The model is initialized with the defined parameters, components are added, and the simulation is run for the specified timesteps. Results are then visualized.</p> Code example: Intiailize, run the simulation, and plot the results <pre><code># Initialize the model\nsir_model = SIRModel(params)\n\n# Initialize and add components\nsir_model.add_component(IntrahostProgression(sir_model))\nsir_model.add_component(Transmission(sir_model))\n\n# Run the simulation\nsir_model.run()\n\n# Plot results\nsir_model.plot_results()\n</code></pre>"},{"location":"tutorials/sir/#spatial-sir","title":"Spatial SIR","text":"<p>Building upon the simple SIR  model created above, we can add spatial complexity to the framework. Here the simple SIR model will spread the population across 20 nodes. The nodes are arranged in a one-dimensional chain and infection spreads spatially from node 0 as agents migrate; migration is based on a migration matrix.</p> <p>Two migration options are available:</p> <ol> <li>Sequential migration matrix: Agents can only move to the next node in the chain.</li> <li>Gravity model migration matrix: Agents can move in a two-dimensional spatial dynamic, where migration probabilities depend on node distances and population sizes.</li> </ol> <p>In this example, the population is distributed across nodes using a rural-urban skew, and migration timers are assigned to control agent migration frequency.</p>"},{"location":"tutorials/sir/#model-components_1","title":"Model components","text":"<p>As above, the model will require the use of <code>LaserFrame</code>, but will now also include spatial components.</p> Code example: Initial model importations <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport csv\nfrom laser_core.laserframe import LaserFrame\nfrom laser_core.demographics.spatialpops import distribute_population_skewed as dps\nfrom laser_core.migration import gravity\n</code></pre> <p>Instead of using the <code>SIRModel</code>, we will use the <code>MultiNodeSIRModel</code>.</p> Code example: Creating a model using <code>MultiNodeSIRModel</code> <pre><code># Define the model\nclass MultiNodeSIRModel:\n    \"\"\"\n    A multi-node SIR (Susceptible-Infected-Recovered) disease transmission model.\n\n    Attributes:\n        params (dict): Configuration parameters for the model.\n        nodes (int): Number of nodes in the simulation.\n        population (LaserFrame): Represents the population with agent-level properties.\n        results (np.ndarray): Stores simulation results for S, I, and R per node.\n        components (list): List of components (e.g., Migration, Transmission) added to the model.\n    \"\"\"\n\n    def __init__(self, params):\n        \"\"\"\n        Initializes the SIR model with the given parameters.\n\n        Args:\n            params (dict): Dictionary containing parameters such as population size,\n                           number of nodes, timesteps, and rates for transmission/migration.\n        \"\"\"\n        self.components = []\n        self.params = params\n        self.nodes = params[\"nodes\"]\n        self.population = LaserFrame(capacity=params[\"population_size\"], initial_count=params[\"population_size\"])\n\n        # Define properties\n        self.population.add_scalar_property(\"node_id\", dtype=np.int32)\n        self.population.add_scalar_property(\"disease_state\", dtype=np.int32, default=0)  # 0=S, 1=I, 2=R\n        self.population.add_scalar_property(\"recovery_timer\", dtype=np.int32, default=0)\n        self.population.add_scalar_property(\"migration_timer\", dtype=np.int32, default=0)\n\n        # Initialize population distribution\n        node_pops = dps(params[\"population_size\"], self.nodes, frac_rural=0.3)\n        node_ids = np.concatenate([np.full(count, i) for i, count in enumerate(node_pops)])\n        np.random.shuffle(node_ids)\n        self.population.node_id[:params[\"population_size\"]] = node_ids\n\n        # Reporting structure: Use LaserFrame for reporting\n        self.results = LaserFrame( capacity=self.nodes ) # not timesteps for capacity\n        for state in [\"S\", \"I\", \"R\"]:\n            self.results.add_vector_property(state, length=params[\"timesteps\"], dtype=np.int32)\n\n        # Record results: reporting could actually be a component if we wanted. Or it can be\n        # done in a log/report function in the relevant component (e.g., Transmission)\n        self.results.S[self.current_timestep, :] = [\n            np.sum(self.population.disease_state[self.population.node_id == i] == 0)\n            for i in range(self.nodes)\n        ]\n        self.results.I[self.current_timestep, :] = [\n            np.sum(self.population.disease_state[self.population.node_id == i] == 1)\n            for i in range(self.nodes)\n        ]\n        self.results.R[self.current_timestep, :] = [\n            np.sum(self.population.disease_state[self.population.node_id == i] == 2)\n            for i in range(self.nodes)\n        ]\n\n    def add_component(self, component):\n        \"\"\"\n        Adds a component (e.g., Migration, Transmission, Recovery) to the model.\n\n        Args:\n            component: An instance of a component to be added.\n        \"\"\"\n        self.components.append(component)\n\n    def step(self):\n        \"\"\"\n        Advances the simulation by one timestep, updating all components and recording results.\n        \"\"\"\n        for component in self.components:\n            component.step()\n\n        # Record results\n        for i in range(self.nodes):\n            in_node = self.population.node_id == i\n            self.results[self.current_timestep, i, 0] = (self.population.disease_state[in_node] == 0).sum()\n            self.results[self.current_timestep, i, 1] = (self.population.disease_state[in_node] == 1).sum()\n            self.results[self.current_timestep, i, 2] = (self.population.disease_state[in_node] == 2).sum()\n\n    def run(self):\n        \"\"\"\n        Runs the simulation for the configured number of timesteps.\n        \"\"\"\n        from tqdm import tqdm\n        for self.current_timestep in tqdm(range(self.params[\"timesteps\"])):\n            self.step()\n\n    def save_results(self, filename):\n        \"\"\"\n        Saves the simulation results to a CSV file.\n\n        Args:\n            filename (str): Path to the output file.\n        \"\"\"\n        with open(filename, mode='w', newline='') as file:\n            writer = csv.writer(file)\n            writer.writerow([\"Timestep\", \"Node\", \"Susceptible\", \"Infected\", \"Recovered\"])\n            for t in range(self.params[\"timesteps\"]):\n                for node in range(self.nodes):\n                    writer.writerow([t, node, *self.results[t, node]])\n\n    def plot_results(self):\n        \"\"\"\n        Plots the prevalence of infected agents over time for all nodes.\n        \"\"\"\n        plt.figure(figsize=(10, 6))\n        for i in range(self.nodes):\n            prevalence = self.results.I[:, i] / (\n                self.results.S[:, i] +\n                self.results.I[:, i] +\n                self.results.R[:, i]\n            )\n            plt.plot(prevalence, label=f\"Node {i}\")\n\n        plt.title(\"Prevalence Across All Nodes\")\n        plt.xlabel(\"Timesteps\")\n        plt.ylabel(\"Prevalence of Infected Agents\")\n        plt.legend()\n        plt.show()\n</code></pre> <p>To add migration between nodes, we will need to select the type of migration model to use and import the component. Here, we will use the sequential migration matrix to move agents sequentially between nodes. The 0th node is the 'urban' node which contains the largest population and where we seed the infection. The infection will travel sequentially from node to node, but the below example breaks the connection at node 13 for demonstrative purposes.</p> Code example: Adding migration using the sequential migration matrix <pre><code>class MigrationComponent:\n    \"\"\"\n    Handles migration behavior of agents between nodes in the model.\n\n    Attributes:\n        model (MultiNodeSIRModel): The simulation model instance.\n        migration_matrix (ndarray): A matrix representing migration probabilities between nodes.\n    \"\"\"\n\n    def __init__(self, model):\n        \"\"\"\n        Initializes the MigrationComponent.\n\n        Args:\n            model (MultiNodeSIRModel): The simulation model instance.\n        \"\"\"\n        self.model = model\n\n        # Set initial migration timers\n        max_timer = int(1 / model.params[\"migration_rate\"])\n        model.population.migration_timer[:] = np.random.randint(1, max_timer + 1, size=model.params[\"population_size\"])\n\n        self.migration_matrix = self.get_sequential_migration_matrix(model.nodes)\n\n        # Example customization: Disable migration from node 13 to 14\n        def break_matrix_node(matrix, from_node, to_node):\n            matrix[from_node][to_node] = 0\n        break_matrix_node(self.migration_matrix, 13, 14)\n\n    def get_sequential_migration_matrix(self, nodes):\n        \"\"\"\n        Creates a migration matrix where agents can only migrate to the next sequential node.\n\n        Args:\n            nodes (int): Number of nodes in the simulation.\n\n        Returns:\n            ndarray: A migration matrix where migration is allowed only to the next node.\n        \"\"\"\n        migration_matrix = np.zeros((nodes, nodes))\n        for i in range(nodes - 1):\n            migration_matrix[i, i + 1] = 1.0\n        return migration_matrix\n\n    def step(self):\n        \"\"\"\n        Updates the migration state of the population by determining which agents migrate\n        and their destinations based on the migration matrix.\n        \"\"\"\n        node_ids = self.model.population.node_id\n\n        # Decrement migration timers\n        self.model.population.migration_timer -= 1\n\n        # Identify agents ready to migrate\n        migrating_indices = np.where(self.model.population.migration_timer &lt;= 0)[0]\n        if migrating_indices.size == 0:\n            return\n\n        # Shuffle migrants and assign destinations based on migration matrix\n        np.random.shuffle(migrating_indices)\n        destinations = np.empty(len(migrating_indices), dtype=int)\n        for origin in range(self.model.nodes):\n            origin_mask = node_ids[migrating_indices] == origin\n            num_origin_migrants = origin_mask.sum()\n\n            if num_origin_migrants &gt; 0:\n                # Assign destinations proportionally to migration matrix\n                destination_counts = np.round(self.migration_matrix[origin] * num_origin_migrants).astype(int)\n                destination_counts = np.maximum(destination_counts, 0)  # Clip negative values\n                if destination_counts.sum() == 0:  # No valid destinations\n                    destinations[origin_mask] = origin  # Stay in the same node\n                    continue\n                destination_counts[origin] += num_origin_migrants - destination_counts.sum()  # Adjust rounding errors\n\n                # Create ordered destination assignments\n                destination_indices = np.repeat(np.arange(self.model.nodes), destination_counts)\n                destinations[origin_mask] = destination_indices[:num_origin_migrants]\n\n        # Update node IDs of migrants\n        node_ids[migrating_indices] = destinations\n\n        # Reset migration timers for migrated agents\n        self.model.population.migration_timer[migrating_indices] = np.random.randint(\n            1, int(1 / self.model.params[\"migration_rate\"]) + 1, size=migrating_indices.size\n        )\n</code></pre> <p>To create more complicated and more realistic migration dynamics, instead of using sequential migration we can use the gravity model to implement 2-D migration. Migration rates are proportional to population sizes, but the example still uses synthetic distances for ease of demonstration.</p> Code example: Adding migration using the gravity model of migration <pre><code>class MigrationComponent2D:\n    \"\"\"\n    Handles migration behavior of agents between nodes in the model.\n\n    Attributes:\n        model (MultiNodeSIRModel): The simulation model instance.\n        migration_matrix (ndarray): A matrix representing migration probabilities between nodes.\n    \"\"\"\n\n    def __init__(self, model):\n        \"\"\"\n        Initializes the MigrationComponent.\n\n        Args:\n            model (MultiNodeSIRModel): The simulation model instance.\n        \"\"\"\n        self.model = model\n\n        # Set initial migration timers\n        max_timer = int(1 / model.params[\"migration_rate\"])\n        model.population.migration_timer[:] = np.random.randint(1, max_timer + 1, size=model.params[\"population_size\"])\n\n        self.migration_matrix = self.get_gravity_migration_matrix(model.nodes)\n\n    def get_gravity_migration_matrix(self, nodes):\n        \"\"\"\n        Generates a gravity-based migration matrix based on population and distances between nodes.\n\n        Args:\n            nodes (int): Number of nodes in the simulation.\n\n        Returns:\n            ndarray: A migration matrix where each row represents probabilities of migration to other nodes.\n        \"\"\"\n        pops = np.array([np.sum(self.model.population.node_id == i) for i in range(nodes)])\n        distances = np.ones((nodes, nodes)) - np.eye(nodes)\n        migration_matrix = gravity(pops, distances, k=1.0, a=0.5, b=0.5, c=2.0)\n        migration_matrix = migration_matrix / migration_matrix.sum(axis=1, keepdims=True)\n        return migration_matrix\n\n    def step(self):\n\n        \"\"\"\n        Executes the migration step for the agent-based model.\n\n        This function selects a fraction of agents to migrate based on expired migration timers.\n        It then changes their node_id according to the migration matrix, ensuring that movements\n        follow the prescribed probability distributions.\n\n        Steps:\n        - Selects a subset of the population for migration.\n        - Determines the origin nodes of migrating agents.\n        - Uses a multinomial draw to assign new destinations based on the migration matrix.\n        - Updates the agents' node assignments accordingly.\n\n        Returns:\n            None\n        \"\"\"\n        # Decrement migration timers\n        self.model.population.migration_timer -= 1\n\n        # Identify agents ready to migrate\n        migrating_indices = np.where(self.model.population.migration_timer &lt;= 0)[0]\n        if migrating_indices.size == 0:\n            return\n\n        np.random.shuffle(migrating_indices)\n\n        origins = model.population.node_id[migrating_indices]\n        origin_counts = np.bincount(origins, minlength=model.params[\"nodes\"])\n\n        offset = 0\n\n        for origin in range(model.params[\"nodes\"]):\n            count = origin_counts[origin]\n            if count == 0:\n                continue\n\n            origin_slice = migrating_indices[offset : offset + count]\n            offset += count\n\n            row = self.migration_matrix[origin]\n            row_sum = row.sum()\n            if row_sum &lt;= 0:\n                continue\n\n            fraction_row = row / row_sum\n            destination_counts = np.random.multinomial(count, fraction_row)\n            destinations = np.repeat(np.arange(model.params[\"nodes\"]), destination_counts)\n            model.population.node_id[origin_slice] = destinations[:count]\n\n        # Reset migration timers for migrated agents\n        self.model.population.migration_timer[migrating_indices] = np.random.randint(\n            1, int(1 / self.model.params[\"migration_rate\"]) + 1, size=migrating_indices.size\n        )\n</code></pre> <p>After selecting your desired migration patterns, you will need to add in a transmission component to create disease dynamics.</p> Code example: Adding in disease transmission <pre><code>class TransmissionComponent:\n    \"\"\"\n    Handles the disease transmission dynamics within the population.\n\n    Attributes:\n        model (MultiNodeSIRModel): The simulation model instance.\n    \"\"\"\n\n    def __init__(self, model):\n        \"\"\"\n        Initializes the TransmissionComponent and infects initial agents.\n\n        Args:\n            model (MultiNodeSIRModel): The simulation model instance.\n        \"\"\"\n        self.model = model\n\n    def step(self):\n        \"\"\"\n        Simulates disease transmission for each node in the current timestep.\n        \"\"\"\n        for i in range(self.model.nodes):\n            in_node = self.model.population.node_id == i\n            susceptible = in_node &amp; (self.model.population.disease_state == 0)\n            infected = in_node &amp; (self.model.population.disease_state == 1)\n\n            num_susceptible = susceptible.sum()\n            num_infected = infected.sum()\n            total_in_node = in_node.sum()\n\n            if total_in_node &gt; 0 and num_infected &gt; 0 and num_susceptible &gt; 0:\n                infectious_fraction = num_infected / total_in_node\n                susceptible_fraction = num_susceptible / total_in_node\n\n                new_infections = int(\n                    self.model.params[\"transmission_rate\"] * infectious_fraction * susceptible_fraction * total_in_node\n                )\n\n                susceptible_indices = np.where(susceptible)[0]\n                newly_infected_indices = np.random.choice(susceptible_indices, size=new_infections, replace=False)\n\n                self.model.population.disease_state[newly_infected_indices] = 1\n                self.model.population.recovery_timer[newly_infected_indices] = np.random.randint(5, 15, size=new_infections)\n</code></pre> <p>Finally, we need to add recovery dynamics to the model to move agents through the disease progression.</p> Code example: Adding in recovery dynamics <pre><code>class RecoveryComponent:\n    \"\"\"\n    Handles the recovery dynamics of infected individuals in the population.\n\n    Attributes:\n        model (MultiNodeSIRModel): The simulation model instance.\n    \"\"\"\n\n    def __init__(self, model):\n        \"\"\"\n        Initializes the RecoveryComponent.\n\n        Args:\n            model (MultiNodeSIRModel): The simulation model instance.\n        \"\"\"\n        self.model = model\n\n    def step(self):\n        \"\"\"\n        Updates the recovery state of infected individuals, moving them to the recovered state\n        if their recovery timer has elapsed.\n        \"\"\"\n        infected = self.model.population.disease_state == 1\n        self.model.population.recovery_timer[infected] -= 1\n        self.model.population.disease_state[(infected) &amp; (self.model.population.recovery_timer &lt;= 0)] = 2\n</code></pre> <p>To run the created model and visualize your output, we will need to set our model parameters and run the simulation.</p> Code example: Running your spatial SIR model <pre><code># Parameters\nparams = {\n    \"population_size\": 1_000_000,\n    \"nodes\": 20,\n    \"timesteps\": 600,\n    \"initial_infected_fraction\": 0.01,\n    \"transmission_rate\": 0.25,\n    \"migration_rate\": 0.001\n}\n\n# Run simulation\nmodel = MultiNodeSIRModel(params)\nmodel.add_component(MigrationComponent(model))\nmodel.add_component(TransmissionComponent(model))\nmodel.add_component(RecoveryComponent(model))\nmodel.run()\nmodel.save_results(\"simulation_results.csv\")\nmodel.plot_results()\n</code></pre>"},{"location":"tutorials/sir/#using-real-data","title":"Using real data","text":"<p>To utilize SIR models to understand real-world transmission dynamics, you will need to use real data. Model structure will be similar to what was presented above, but instead of using a synthetic population we will initialize the model using real population data. In this example, we will use data from Rwanda. You will want your data saved in a .csv file, with the following format:</p> <p><code>region_id,population,centroid_lat,centroid_long,birth_rate Ryansoro,46482.66796875,-3.707268618580818,29.79879895068512,11.65647 Ndava,72979.296875,-3.391556716979041,29.753430749757815,15.881549 Buyengero,76468.8125,-3.8487418774123014,29.53299692786253,12.503805 Bugarama,44571.8515625,-3.6904789341549504,29.400408879716224,11.025566 Rumonge,300248.03125,-3.9622108122897663,29.45711276535364,19.567726 Burambi,63219.703125,-3.798641437985548,29.452423323952797,9.199019 Kanyosha1,115017.984375,-3.4309688424403473,29.41531324224386,37.951366 Kabezi,71913.8359375,-3.5311012728218527,29.369968675926785,31.831919 Muhuta,88141.7109375,-3.623512958448508,29.415218642943234,21.598902</code></p>"}]}