{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LASER documentation","text":"<p>LASER (Light Agent Spatial modeling for ERadication) is a high-performance, agent-based simulation framework for modeling the spread of infectious diseases. It supports spatial structure, age demographics, and modular disease logic using Python-based components. LASER provides flexible components for creating, extending, and calibrating dynamic epidemiological models.</p> <p>LASER has several pre-built models that you can use to explore disease dynamics without the need to code a model from scratch. These models include built-in examples ranging from simple compartmental models to more complex agent-based models with spatial dynamics. The modular structure of LASER also enables you to build custom models to fit particular research needs, through the integration or modification of the LASER-core components. As an open source model, the LASER team also encourages experienced users to extend the LASER framework by contributing to code!</p>"},{"location":"glossary/","title":"Glossary","text":"<p>lower priority, but a glossary of terms (would definitely include all laser-specific terms, eg \"component\" so that users have an additional reference manual for help)</p>"},{"location":"installation/","title":"Installation and software requirements","text":"<p>Environment requirements</p> <p>Pip install laser-generic</p> <p>Pip install laser-core (?)</p> <p>Other versions?</p> <p>Other notes?</p> <p>Info on Jenner, or other AI set-up instructions</p> <p>Installation for development should go with the development &amp; contributing to code section (could be here too with a link there, but should be in the dev section)</p> <p>[For example, on the \"Calibration workflow for laser models\" page, the prereq's include a Python environment with optuna, pandas, and numpy installed, so there should be info on what's necessary in your enviro, if it's not all installed with the Pip install]</p>"},{"location":"development/","title":"Development and Contributing to Code","text":"<p>Here's where all the relevant info for submitting tickets for bugs or feature requests, how to contribute to code, etc should go. No need to include persona information, users will navigate the docs based on what tasks they want to do.</p>"},{"location":"development/#bugs-and-improvements","title":"Bugs and improvements","text":"<p>all info for filing tickets, requesting doc improvements, or new features can go here (it should all basically be \"how to file a ticket with us on GH\")</p>"},{"location":"development/#contributing-to-code","title":"Contributing to code","text":"<p>Introduction to the topic: will include the basic how-tos of working with the IDM team as well as how to actually work on LASER code</p>"},{"location":"development/#github-best-practices","title":"GitHub best practices","text":"<p>how to engage with IDM on GH, what's required for PRs etc (not bug tickets but how to fork &amp; submit PRs)</p>"},{"location":"development/#development-best-practices","title":"Development best practices","text":"<p>other help that's not related to unit tests or code optimization, relevant info from the \"iterative development cycle\" can go here (only if it's actual workflow steps; don't include if that's just a generalized workflow)</p>"},{"location":"development/#running-testsunit-tests","title":"Running tests/unit tests","text":"<p>all relevant sections on unit tests and code testing</p>"},{"location":"development/#optimizing-code","title":"Optimizing code","text":"<p>I'd include the help with Numba, Numpy here, and the info on C and OpenMP.</p>"},{"location":"get-started/","title":"Get Started Modeling","text":"<p>This is the basis for USING laser. Any type of \"quickstart\" info, all the how-to, what to do, etc goes in this section. This landing page should provide a layout of the relevant topics, and let users know that there are prebuilt disease models (including generic) as well as bespoke modeling options using core.</p>"},{"location":"get-started/prebuilt/","title":"Laser Disease Models","text":"<p>Link away to docsets for Generic, Measles, Cholera? (others as they're built)</p> <p>Will want the disease-specific docsets to contain:</p> <ul> <li>installation/setup/requirements</li> <li>new features/modules (eg what's added from core)</li> <li>creating sims</li> <li>running sims</li> <li>calibration</li> <li>tutorials &amp; examples</li> <li>parameters &amp; api docs</li> </ul>"},{"location":"get-started/custom/","title":"Creating Custom Models","text":"<p>How to model using LASER-core components</p> <p>Installation should be already done, those instructions were on the installation page (link to it)</p> <p>Potential list of topics (edit based on how you actually do this! This may end up being a landing page, and each topic has its own page)</p>"},{"location":"get-started/custom/#assembling-componentsbuilding-a-model","title":"Assembling components/building a model","text":"<p>make sure to include the base requirements: what components are needed to run a model? How do you create the base model? (define parameters, add components, run sim, visualize output?)</p>"},{"location":"get-started/custom/#manually","title":"Manually","text":""},{"location":"get-started/custom/#setting-up-jenner-or-your-own-ai-interface","title":"Setting up Jenner (or your own AI interface)","text":""},{"location":"get-started/custom/#running-simulations","title":"Running simulations","text":""},{"location":"get-started/custom/#visualize-output","title":"Visualize output","text":"<p>Note: pulled out the sections loading data, initializing populations, squashing/saving/loading, and put them on a separate topic page. BUT if they should all be done prior to running sims, then should integrate them into this page, with \"running simulations\" as the last step. (I don't fully understand how to actually build a model yet, so this section of the TOC is still squishy).</p> <p>This page should focus on the basics of what to do, all of the \"additional\" tasks are subpages.</p>"},{"location":"get-started/custom/calibration/","title":"Calibrating Custom Models","text":"<p>LASER can be calibrated using Optuna. Calibration is a process of tuning model parameters to fit real-world data, to ensure that model output provides accurate insights. Calibration can also be used as a method to help debug your model, as an inability to recreate known phenomena can help pinpoint issues in model code. For more information on calibration, check out IDM's ModelingHub.</p>"},{"location":"get-started/custom/calibration/#simple-local-calibration","title":"Simple local calibration","text":""},{"location":"get-started/custom/calibration/#local-dockerized-calibration","title":"Local Dockerized calibration","text":""},{"location":"get-started/custom/calibration/#cloud-calibration","title":"Cloud calibration","text":""},{"location":"get-started/custom/complexity/","title":"Adding Model Complexity","text":"<p>This will include how-to's for setting up the cool bits</p>"},{"location":"get-started/custom/complexity/#vital-dynamics","title":"Vital dynamics","text":""},{"location":"get-started/custom/complexity/#adding-spatial-features","title":"Adding spatial features","text":""},{"location":"get-started/custom/complexity/#adding-migration","title":"Adding migration","text":""},{"location":"get-started/custom/initialization/","title":"Loading Data and Initializing Populations","text":"<p>On the fence about making this a separate page, or including in the main page with the \"building\" sections; mostly, if these are somewhat optional but will make the model better, should have a separate topic page. If they're necessary, put back on the landing page (prior to \"running simulations\")</p>"},{"location":"get-started/custom/initialization/#loading-data","title":"Loading data...","text":""},{"location":"get-started/custom/initialization/#initializing-populations","title":"Initializing populations","text":""},{"location":"get-started/custom/initialization/#squashing-saving-loading","title":"Squashing, saving, loading ..?","text":"<p>Note that the code example fr</p>"},{"location":"get-started/custom/initialization/#other-pre-run-tasks-","title":"Other pre-run tasks :-)","text":""},{"location":"get-started/custom/optimization/","title":"Optimizing Custom Models","text":"<p>As an agent-based model, research using LASER will require thousands of simulation replicates. While the model is designed to perform well with populations of thousands of agents, there is still a need to utilize high compute power and to optimize model performance.</p> <p>When creating custom models, knowing how to identify and fix performance bottlenecks can save compute time and speed results.</p>"},{"location":"get-started/custom/optimization/#identifying-bottlenecks","title":"Identifying bottlenecks","text":""},{"location":"get-started/custom/optimization/#leveraging-ai","title":"Leveraging AI","text":""},{"location":"get-started/custom/optimization/#implementing-unit-tests","title":"Implementing unit tests","text":""},{"location":"get-started/custom/optimization/#optimizing-with-numpy-and-numba","title":"Optimizing with NumPy and Numba","text":""},{"location":"get-started/custom/optimization/#c-and-openmp","title":"C and OpenMP","text":""},{"location":"parameters/","title":"Parameter Reference","text":"<p>API docs!! All the relevant info needs to be here</p>"},{"location":"software-overview/","title":"Software Overview","text":"<p>LASER is a modeling framework that includes a variety of ways for users to implement the code to model infectious diseases. At the root of the framework is LASER-core, a suite of components that can be assembled or customized to fit specific modeling needs. The LASER development team is also in the process of producing pre-built disease models crafted from LASER-core components, which are tailored to address specific public health modeling questions. You can learn more about creating custom models using LASER-core or running models using pre-built disease models in the Get Started Modeling section.</p>"},{"location":"software-overview/#design-principles","title":"Design principles","text":"<p>The philosophy driving the development of LASER was to create a framework that was flexible, powerful, and fast, able to tackle a variety of complex modeling scenarios without sacrificing performance. But complexity often slows performance, and not every modeling question requires a full suite of model features. To solve this problem, LASER was designed as a set of core components, each with fundamental features that could be added--or not--to build working models. Users can optimize performance by creating models tailored to their research needs, only using components necessary for their modeling question. This building-block framework enables parsimony in model design, but also facilitates the building of powerful models with bespoke, complex dynamics.</p>"},{"location":"software-overview/#software-architecture","title":"Software architecture","text":"<p>Framework of how laser works:</p>"},{"location":"software-overview/files/","title":"Input and Output Files","text":"<p>All info on the input files and output files. If there are built-in reports, include those. Any type of data requirements should also be included here.</p> <p>Even if there are no \"required\" files, there still needs to be guidelines on formats, basic information needs, example files, etc. Better to provide some guidelines and let users know they're flexible than to say \"anything goes\" with out any starting point</p>"},{"location":"software-overview/modules/","title":"Modules (or Models?)","text":"<p>Looks like there are \"model classes\" that manage components?? (Looking at the Vital Dynamics Model page)</p> <p>Rename \"Classes\" depending on what the architecture actually is.</p> <p>May need a drop-down section like components if we have multiple types; right now it looks like Vital Dynamics would go here</p>"},{"location":"software-overview/components/","title":"Software Components","text":"<p>Components are modular units of functionality within the simulation, responsible for performing specific updates or computations on the agent population or node-level data. Each component is implemented as a class with an initialization function to set up any required state and a step function to execute the component\u2019s logic during each timestep.</p> <p>[Deep dive into components and how they work, how they comprise laser functionality. Each \"type\" of component will have a topic section as needed]</p> <p>Make it clear that this is not a comprehensive list, but a call-out for the various functions the user can play with (link to API docs for full listing of laser functions)</p>"},{"location":"software-overview/components/database/","title":"Simulation Data and Properties","text":"<p>I think it's worth calling out LaserFrame and PropertySet as features, since this is where the nuts and bolts seem to happen (page could use a better title)</p> <p>LaserFrame: basically a database that manages the dynamically allocated data for agents and nodes</p> <p>PropertySet: stores the agent properties in a dictionary-like object (such as infection status, region, exposure timers, etc)</p>"},{"location":"software-overview/components/demographics/","title":"Demographics","text":"<p>Need to an an intro, explaining generalizations about demographics for LASER.</p> <p>ALL topics about demographics will go here:</p> <ul> <li>Age structure</li> <li>Births</li> <li>Deaths</li> <li>All the vital dynamics sections??</li> <li>population pyramids</li> <li>kapalan-meier estimator</li> <li>etc</li> </ul> <p>Just pasted in content from the various topics; this will need an intro and text explaining how to configure these, how they fit together (eg, when to use age pyrmaids, when to use kaplan-meier); also code blocks, etc need to be formatted</p> <p>SO: Vital dynamics model: that section probably needs its own topic page, since it's long. Still kind of confused about what a \"model\" is in terms of laser components--is this a stand-alone model? Or the 'piece' that implements vital dynamics within an actual model? The answer to that will determine where we put the VDM topic page in the TOC.</p> <p>Also, make sure to link to appropriate topics! (esp parameters)</p>"},{"location":"software-overview/components/demographics/#age-structure","title":"Age structure","text":"<p>If you want to work with age structure for a short simulation which doesn\u2019t need births you can just give everyone an age (based on distribution) and increment it each timestep. The laser_core.demographics.pyramid module is provided to support the initialization of agents with plausible initial ages.</p>"},{"location":"software-overview/components/demographics/#births","title":"Births","text":""},{"location":"software-overview/components/demographics/#preborn-management-in-laser","title":"Preborn management in LASER","text":"<p>LASER\u2019s design philosophy emphasizes contiguous and fixed-size arrays, meaning all agents\u2014both currently active and preborn\u2014are created at the start of the simulation. Preborns are \u201cactivated\u201d as they are born, rather than being dynamically added. Several approaches to handling preborns while adhering to these principles are outlined below:</p> <p>Negative and Positive Birthdays: - Assign date_of_birth values in the past (negative) for active agents. - Assign date_of_birth values in the future (positive) for preborns.</p> <p>Unified Preborn Marker: - Set all preborns\u2019 date_of_birth to a placeholder value (e.g., -1). - Update the date_of_birth to the current timestep when a preborn is born.</p> <p>Active Flag Only (if not modeling age structure): - If the model doesn\u2019t require age structure, you can skip date_of_birth entirely. Instead, use an active flag. Preborns start with active = False and are switched to active = True during the fertility step. This simplifies implementation while remaining consistent with LASER principles.</p>"},{"location":"software-overview/components/demographics/#calculating-age-from-birthday","title":"Calculating age from birthday","text":"<p>If calculating age isn\u2019t frequent or essential, you can avoid explicitly tracking an age property. Instead, compute age dynamically as the difference between the current timestep (now) and date_of_birth. For models that depend on age-specific dynamics (e.g., fertility rates by age group), consider adding a dedicated age property that updates at each timestep.</p>"},{"location":"software-overview/components/demographics/#deaths","title":"Deaths","text":"<p>The recommended way of doing mortality in LASER is by precalculating a lifespan for each agent, rather than probabilistically killing agents as the simulation runs. This can take different forms: If you prefer to track agent age, you can also have an agent lifespan. Alternatively, if you are just using date_of_birth you can have a date_of_death, where theses \u2018dates\u2019 are really simulation times (\u2018sim day of birth\u2019 and \u2018sim day of death\u2019). Also, in LASER, as mentioned in the \u2018Principles\u2019 section, we strive to leave the contiguous arrays of agent data in place, without adding or deleting elements (allocating or freeing). This means that to model mortality, we prefer to \u2018kill\u2019 agents by doing either 1) check that their age is greater than their lifespan (or that the current timestep is greater than their \u2018sim day of death\u2019) in each component that cares, or 2) Set an active flag to false or a dead flag to true. The second approach is simpler, and avoids doing millions of comparison operations, at the cost of an additional property. Note that many component operations (step functions) can be done without checking whether the agent is alive, because, for example, as long as transmission never infects a dead person, decrementing all non-zero infection timers will only operate on live agents. Finally, while you can set lifespans using any algorith you want, laser_core.demographics.kmestimator is provided to support these calculations.</p>"},{"location":"software-overview/components/demographics/#population-pyramids","title":"Population pyramids","text":"<p>The AliasedDistribution class provides a way to sample from a set of options with unequal probabilities, e.g., a population pyramid.</p> <p>The input to the AliasedDistribution constructor is an array of counts by bin as we would naturally get from a population pyramid (# of people in each age bin).</p> <p>AliasedDistribution.sample() returns bin indices so it is up to the user to convert the values returned from sample() to actual ages.</p> <p>Expected format of the population pyramid CSV file for load_pyramid_csv(): [insert examples]</p>"},{"location":"software-overview/components/demographics/#kaplan-meier-estimators","title":"Kaplan-Meier estimators","text":"<p>The KaplanMeierEstimator is used to predict age or year of death. It takes an array of cumulative deaths and returns an object that will sample from the Kaplan-Meier distribution.</p> <p>A sample input array of cumulative deaths might look like this:</p> <pre><code>cd[0] = 687 # 687 deaths in the first year (age 0)\ncd[1] = 733 # +46 deaths in the second year (age 1)\ncd[2] = 767 # +34 deaths in the third year (age 2)\n...\ncd[100] = 100_000  # 100,000 deaths by end of year\n</code></pre> <p><code>predict_year_of_death()</code> takes an array of current ages (in years) and returns an array of predicted years of death based on the cumulative deaths input array.</p> <p>Note</p> <p><code>predict_year_of_death()</code> can use non-constant width age bins and will return predictions by age bin. In this case, it is up to the user to convert the returned bin indices to actual years.</p> <p>A sample non-constant width age bin input array might look like this:</p> <pre><code>cd[0] = 340 # 1/2 of first year deaths in the first 3 months\ncd[1] = 510 # another 1/4 (+170) of first year deaths in the next 3 months\ncd[2] = 687 # another 1/4 (+177) of first year deaths in the last 6 months\ncd[3] = 733 # 46 deaths in the second year (age 1)\ncd[4] = 767 # 34 deaths in the third year (age 2)\n...\ncd[103] = 100_000  # 100,000 deaths by end of year 100\n</code></pre> <p>In this example, values returned from predict_year_of_death() would need to be mapped as follows:</p> <pre><code>0 -&gt; (0, 3] months\n1 -&gt; (3, 6] months\n2 -&gt; (6, 12] months\n3 -&gt; 1 year\n4 -&gt; 2 years\n...\n102 -&gt; 100 years\n</code></pre> <p><code>predict_age_at_death()</code> takes an array of current ages (in days) and returns an array of predicted ages (in days) at death. The implementation assumes that the cumulative deaths input array to the estimator represents one year age bins. If you are using non-constant width age bins, you should manually convert bin indices returned from <code>predict_year_of_death()</code> to ages.</p>"},{"location":"software-overview/components/demographics/#spatial-distributions-of-populations","title":"Spatial distributions of populations","text":"<p>[Added here since it's part of the demographics subpackage, but it might make more sense with the migration information]</p>"},{"location":"software-overview/components/migration/","title":"Migration","text":"<p>ADD INTRO (yes, all types are included as options in the migration module)</p>"},{"location":"software-overview/components/migration/#gravity-model","title":"Gravity model","text":"<p>The gravity model [link to a good source on GM] can be used to compute the migration of people between nodes located at specific distances.</p> <p>The following example demonstrates implementing the gravity model to calculate the number of migrants moving between nodes. Agents are randomly assigned to different migration paths.</p> <pre><code>import numpy as np\nfrom laser_core.migration import gravity\n\n# Define populations and distances\npopulations = np.array([5000, 10000, 15000, 20000, 25000])  # Unequal populations\ndistances = np.array([\n    [0.0, 10.0, 15.0, 20.0, 25.0],\n    [10.0, 0.0, 10.0, 15.0, 20.0],\n    [15.0, 10.0, 0.0, 10.0, 15.0],\n    [20.0, 15.0, 10.0, 0.0, 10.0],\n    [25.0, 20.0, 15.0, 10.0, 0.0]\n])\n\n# Gravity model parameters\nk = 0.1    # Scaling constant\na = 0.5    # Exponent for the population of the origin\nb = 1.0    # Exponent for the population of the destination\nc = 2.0    # Exponent for the distance\n\n# Compute the gravity model network\nmigration_network = gravity(populations, distances, k=k, a=a, b=b, c=c)\n\n# Normalize to ensure total migrations represent 1% of the population\ntotal_population = np.sum(populations)\nmigration_fraction = 0.01  # 1% of the population migrates\nscaling_factor = (total_population * migration_fraction) / np.sum(migration_network)\nmigration_network *= scaling_factor\n\n# Generate a node ID array for agents\nnode_ids = np.concatenate([np.full(count, i) for i, count in enumerate(populations)])\n\n# Initialize a 2D array for migration counts\nmigration_matrix = np.zeros_like(distances, dtype=int)\n\n# Select migrants based on the gravity model\nfor origin in range(len(populations)):\n    for destination in range(len(populations)):\n        if origin != destination:\n            # Number of migrants to move from origin to destination\n            num_migrants = int(migration_network[origin, destination])\n            # Select migrants randomly\n            origin_ids = np.where(node_ids == origin)[0]\n            selected_migrants = np.random.choice(origin_ids, size=num_migrants, replace=False)\n            # Update the migration matrix\n            migration_matrix[origin, destination] = num_migrants\n</code></pre>"},{"location":"software-overview/components/migration/#sequential-migration-matrix","title":"Sequential migration matrix","text":"<p>Saw a reference to this in the \"simple spatial SIR model with synthetic data\" section, so need info on it.</p>"},{"location":"software-overview/components/migration/#the-competing-destinations-model","title":"The competing destinations model","text":""},{"location":"software-overview/components/migration/#stouffers-rank-model","title":"Stouffer's rank model","text":""},{"location":"software-overview/components/migration/#radiation-model","title":"Radiation model","text":""},{"location":"tutorials/","title":"Tutorials and Examples","text":"<p>This will definitely need some secondary structure, so that the tutorials make sense and are findable. They will likely include tutorials for a variety of tasks, so organization is key. Also note that code blocks that are examples of specific instructions/topics should go on the topic page; this section is where users will run models and do more end-to-end workflow type examples. Can also link to notebooks here (but make sure notebooks have good introductions and explanations</p> <p>[include internal TOC for list of examples]</p> <p>Note: had this under the \"getting started\" section, but thinking it is better served as a L1 topic.</p>"},{"location":"tutorials/sir/","title":"Building an SIR Model","text":"<p>So there are multiple SIR model examples currently in the doc; I think it would make sense to have a single SIR tutorial, where you add complexity to the framework (unless there's something very different?). Basically, start with simple SIR, add spatial dynamics, add real data, add other functions, etc (start in the most basic way and then build up each new feature). It seems easier to keep the topic as one instead of multiple SIR topics floating around.</p> <p>Make sure the instructions/introduction clearly states that this is using laser-core (in case there are other sir models using generic, etc)</p>"},{"location":"tutorials/sir/#simple-sir","title":"Simple SIR","text":""},{"location":"tutorials/sir/#spatial-sir","title":"Spatial SIR","text":""},{"location":"tutorials/sir/#using-synthetic-data","title":"Using synthetic data","text":""},{"location":"tutorials/sir/#using-real-data","title":"Using real data","text":""}]}